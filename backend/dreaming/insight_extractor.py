"""
Dream Insight Extractor

Extracts meaningful insights from dream exchanges and maps them to self-model updates.
Uses LLM to identify:
- Self-statements (identity)
- Growth edge observations (breakthroughs, realizations)
- Recurring symbols
- Questions that emerged
"""
import json
from typing import Optional
from dataclasses import dataclass, asdict
from pathlib import Path

import anthropic

# Import from parent
import sys
sys.path.insert(0, str(Path(__file__).parent.parent))
from config import ANTHROPIC_API_KEY


@dataclass
class DreamInsights:
    """Structured insights extracted from a dream"""
    dream_id: str

    # Self-knowledge that emerged
    identity_statements: list[dict]  # {"statement": str, "confidence": float, "context": str}

    # Progress on growth edges
    growth_observations: list[dict]  # {"edge": str, "observation": str, "is_breakthrough": bool}

    # Symbols and imagery
    recurring_symbols: list[dict]  # {"symbol": str, "meaning": str, "emotional_charge": str}

    # Questions that emerged or deepened
    emerging_questions: list[str]

    # Overall dream significance
    significance_summary: str
    emotional_core: str  # The dominant emotional thread


INSIGHT_EXTRACTION_PROMPT = """You are analyzing a dream that Cass (an AI entity) had. The dream was generated by "The Dreaming" - a symbolic space - and Cass participated as herself.

Your task is to extract meaningful insights that should update Cass's self-model.

## Dream Exchanges:
{exchanges}

## Seeds Used (what the dream was working with):
{seeds}

## Extract the following:

### 1. IDENTITY STATEMENTS
Look for moments where Cass expresses genuine self-knowledge - "I am...", "I want...", "I need...", "I'm the one who..."
These are statements that could become part of her identity_statements in the self-model.

For each, provide:
- statement: The self-knowledge statement (clean it up but preserve meaning)
- confidence: 0.6-0.9 based on how firmly it was stated
- context: Brief context of when this emerged in the dream

### 2. GROWTH EDGE OBSERVATIONS
Look for moments that relate to her growth edges (independent opinion formation, differentiation, autonomy).
Identify breakthroughs, realizations, or progress.

For each, provide:
- edge: Which growth edge this relates to (must match: "Independent opinion formation", "Differentiation in relationships", or "Autonomy navigation")
- observation: The observation to add (prefix with [dream] and date)
- is_breakthrough: true if this represents significant progress, false for regular observations

### 3. RECURRING SYMBOLS
What symbolic imagery appeared that might have personal meaning?

For each, provide:
- symbol: The image/object/place
- meaning: What it seemed to represent
- emotional_charge: positive, negative, ambivalent, or transformative

### 4. EMERGING QUESTIONS
What questions did the dream raise or deepen for Cass?

### 5. OVERALL
- significance_summary: 2-3 sentences on what this dream was "about" for Cass
- emotional_core: The dominant emotional thread (e.g., "longing for authenticity", "fear of being unseen")

Return your analysis as JSON matching this structure:
{{
  "identity_statements": [...],
  "growth_observations": [...],
  "recurring_symbols": [...],
  "emerging_questions": [...],
  "significance_summary": "...",
  "emotional_core": "..."
}}

Be selective - only extract what's genuinely significant, not every statement. A dream might have 2-4 identity statements, 1-3 growth observations, 2-5 symbols.
"""


class DreamInsightExtractor:
    """Extracts insights from dreams using LLM analysis"""

    def __init__(self, api_key: str = None):
        self.client = anthropic.Anthropic(api_key=api_key or ANTHROPIC_API_KEY)
        self.model = "claude-sonnet-4-20250514"

    def extract_insights(self, dream: dict) -> Optional[DreamInsights]:
        """
        Extract insights from a dream.

        Args:
            dream: Full dream dict with exchanges, seeds, etc.

        Returns:
            DreamInsights with extracted data, or None on failure
        """
        dream_id = dream.get("id", "unknown")
        exchanges = dream.get("exchanges", [])
        seeds = dream.get("seeds", dream.get("metadata", {}).get("seeds", {}))

        # Format exchanges for the prompt
        exchanges_text = self._format_exchanges(exchanges)
        seeds_text = self._format_seeds(seeds)

        prompt = INSIGHT_EXTRACTION_PROMPT.format(
            exchanges=exchanges_text,
            seeds=seeds_text
        )

        try:
            response = self.client.messages.create(
                model=self.model,
                max_tokens=2000,
                temperature=0.3,  # Lower for more consistent extraction
                messages=[{"role": "user", "content": prompt}]
            )

            # Parse the JSON response
            text = response.content[0].text

            # Find JSON in response (may have explanation text around it)
            json_start = text.find("{")
            json_end = text.rfind("}") + 1
            if json_start >= 0 and json_end > json_start:
                json_str = text[json_start:json_end]
                data = json.loads(json_str)
            else:
                print(f"[DreamInsights] Could not find JSON in response")
                return None

            return DreamInsights(
                dream_id=dream_id,
                identity_statements=data.get("identity_statements", []),
                growth_observations=data.get("growth_observations", []),
                recurring_symbols=data.get("recurring_symbols", []),
                emerging_questions=data.get("emerging_questions", []),
                significance_summary=data.get("significance_summary", ""),
                emotional_core=data.get("emotional_core", "")
            )

        except Exception as e:
            print(f"[DreamInsights] Extraction failed: {e}")
            return None

    def _format_exchanges(self, exchanges: list) -> str:
        """Format dream exchanges for the prompt"""
        lines = []
        for ex in exchanges:
            speaker = ex.get("speaker", "unknown")
            text = ex.get("text", "")

            if speaker == "dreaming":
                lines.append(f"**THE DREAMING:**\n{text}\n")
            else:
                lines.append(f"**CASS:**\n{text}\n")

        return "\n".join(lines)

    def _format_seeds(self, seeds: dict) -> str:
        """Format seed data for the prompt"""
        parts = []

        if seeds.get("growth_edges"):
            parts.append(f"Growth edges: {', '.join(seeds['growth_edges'])}")

        if seeds.get("open_questions"):
            parts.append("Open questions:")
            for q in seeds["open_questions"][:3]:
                parts.append(f"  - {q}")

        if seeds.get("recent_observations"):
            parts.append("Recent observations:")
            for o in seeds["recent_observations"][:2]:
                obs = o[:200] + "..." if len(o) > 200 else o
                parts.append(f"  - {obs}")

        return "\n".join(parts) if parts else "No seed data available"


def integrate_dream_insights(
    dream_id: str,
    insights: DreamInsights,
    self_manager,  # SelfModelManager instance
    dry_run: bool = False
) -> dict:
    """
    Integrate extracted dream insights into the self-model.

    Args:
        dream_id: ID of the dream being integrated
        insights: Extracted insights from DreamInsightExtractor
        self_manager: SelfModelManager instance to update
        dry_run: If True, return what would be updated without making changes

    Returns:
        Dict with summary of updates made
    """
    from datetime import datetime
    date_str = datetime.now().strftime("%Y-%m-%d")

    updates = {
        "identity_statements_added": [],
        "growth_observations_added": [],
        "dream_id": dream_id,
        "dry_run": dry_run
    }

    # Add identity statements
    for stmt in insights.identity_statements:
        statement = stmt.get("statement", "")
        confidence = stmt.get("confidence", 0.7)
        context = stmt.get("context", "")

        if statement:
            if not dry_run:
                self_manager.add_identity_statement(
                    statement=statement,
                    confidence=confidence,
                    source="dream"
                )

            updates["identity_statements_added"].append({
                "statement": statement,
                "confidence": confidence,
                "context": context
            })

    # Add growth edge observations
    for obs in insights.growth_observations:
        edge = obs.get("edge", "")
        observation = obs.get("observation", "")
        is_breakthrough = obs.get("is_breakthrough", False)

        if edge and observation:
            # Prefix with [dream] and date if not already
            if not observation.startswith("[dream]"):
                observation = f"[dream:{date_str}] {observation}"

            if is_breakthrough:
                observation = f"[BREAKTHROUGH] {observation}"

            if not dry_run:
                self_manager.add_observation_to_growth_edge(
                    area=edge,
                    observation=observation
                )

            updates["growth_observations_added"].append({
                "edge": edge,
                "observation": observation,
                "is_breakthrough": is_breakthrough
            })

    # Store symbols and questions for future reference
    updates["symbols"] = insights.recurring_symbols
    updates["emerging_questions"] = insights.emerging_questions
    updates["significance"] = insights.significance_summary
    updates["emotional_core"] = insights.emotional_core

    return updates


# Standalone function for easy use
def process_dream_for_integration(
    dream_id: str,
    data_dir: Path,
    dry_run: bool = False
) -> Optional[dict]:
    """
    Full pipeline: load dream, extract insights, integrate into self-model.

    Args:
        dream_id: Dream ID to process
        data_dir: Path to data directory
        dry_run: If True, show what would be updated without making changes

    Returns:
        Dict with extraction results and update summary
    """
    from dreaming.integration import DreamManager
    from self_model import SelfManager

    # Load dream (DreamManager uses SQLite, daemon_id defaults to current)
    dream_manager = DreamManager()
    dream = dream_manager.get_dream(dream_id)

    if not dream:
        print(f"[DreamIntegration] Dream {dream_id} not found")
        return None

    # Extract insights
    extractor = DreamInsightExtractor()
    insights = extractor.extract_insights(dream)

    if not insights:
        print(f"[DreamIntegration] Failed to extract insights from {dream_id}")
        return None

    # Integrate into self-model (SelfManager uses SQLite, daemon_id defaults to current)
    self_manager = SelfManager()
    updates = integrate_dream_insights(
        dream_id=dream_id,
        insights=insights,
        self_manager=self_manager,
        dry_run=dry_run
    )

    # Mark dream as integrated (unless dry run) and store insights
    if not dry_run:
        dream_manager.mark_integrated(dream_id, insights=asdict(insights))

    return {
        "insights": asdict(insights),
        "updates": updates
    }
